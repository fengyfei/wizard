# 作用域



## 作用域是什么

对于大多数语言来说，能够访问存储变量当中的值，并且能够在之后的操作中对其进行访问或修改应该是最基本的功能之一。但是将变量引入程序的话就会出现一些问题，比如这些变量存储在哪里，程序需要时如何去找到他们等等。由此一来，我们就需要设计一套良好的规则去存储变量，并且之后可以方便的找到这些变量，而这套规则，就被称为作用域。

这里简单举一个例子，来理解一下JS的编译过程。在宏观上来看，对于  ```var a = 2；  ```来说，在执行它之前要经历三个步骤。

* 分词/词法分析

  这个过程将由字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元（token）。对于咱们所举的这个例子来说，会被分解成 var ， a， =， 2， ；。至于空格会不会被当作词法单元，就要看空格在这里是否具有意义。

* 解析/语法分析

  这个过程就是将词法单元流转换成一个由元素逐级嵌套组成的代表了程序语法结构的树，被称为‘’ 语法抽象树 ‘（Abstract Syntax Tree  ， AST ）’对于本例来说，该树可能会有一个叫做 VariableDeclaration 的顶级节点，加下来是叫做 Identifier 的子节点（它的值是 a ），以及一个叫做 AssignmentExpression 的子节点。 AssignmentExpression 节点有一个叫做 Numericliteral （它的值是 2 ）的子节点。

* 代码生成

  将 AST 转换为可执行代码的过程被称为代码生成，简单来说，也就是用某种方法将 ``` var = 2; ```的 AST 转化为一组机械指令，用来创建一个叫做 a 的变量（包括内存分配），并将一个值存储在 a 中。

  ​

当然，JS的引擎要复杂的多，比如在词法分析和代码生成阶段有特定的步骤来对运行性能进行优化等等。在这里，我们只是进行宏观的，简单的介绍。

## 理解作用域

我们将这个过程模拟成几个人物之间的对话，来便于我们去学习作用域。

首先，我们来介绍这几个出场人物

* 引擎

  从头到尾负责整个 JavaScript 程序的编译及执行过程

* 编译器

  引擎的好朋友之一，负责语法分析及代码生成等工作

* 作用域

  引擎的另一位好朋友，负责收集并维护所有声明的标志符组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

当你看到 ```var a = 2;```时，很可能认为这是一句声明。但是引擎不是这么看的，它会认为这是两个完全不同的声明，事实上编译器会进行如下处理

1. 遇到```var a```，编辑器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a。

2. 接下来编译器会引擎生成运行时所需的代码。这些代码被用来处理```a = 2```的赋值操作。引擎运行时会首先询问作用域，在当前作用域集合中是否存在一个叫做 a 的变量。如果是，引擎就会使用这个变量 ；如果否，引擎会继续查找该变量。

   ​

如果引擎最后找到了这个变量 a ，就会将 2 赋值给它，不然引擎就会跑出一个异常。

**总结**：变量的赋值操作会执行两个动作，首先编译器会在当前的作用域中声明一个变量，然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对其赋值。

这里再介绍两个编译器的术语，便于我们进一步理解作用域。

LHS 查找和 RHS 查找，L 和 R 当然就是代表左侧和右侧，但是是什么的左侧和右侧，是一个赋值操作的左侧和右侧。换句话说，当变量出现在赋值操作的左侧时，进行 LHS 查询，出现在右侧时进行 RHS 查询。说的再简单一点，RHS 就是简单的查找某个变量，而 LHS 就是要得到某某的值。

```text
console.log( a );
```

这里对 a 的引用就是一个 RHS 引用，因为这里 a 并没有被赋于任何值。而是需要去查找 a 的值，这样才能够将值传递给 console.log(…)。

相比之下，例如

```tex
a = 2;
```

这里对 a 的引用就是一个 LHS 引用，因为这里我们不关心当前的值是什么，只是想要为 = 2 这个赋值操作找一个目标。

考虑一下这段代码，引擎和作用域之间应该如何对话。

```text
function foo(a) {
	var b = a;
	return a + b;
}
var c = foo(2);
```

## 作用域嵌套

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量或者抵达最外层的作用域（全局作用域）为止。

```text
function foo(a) {
	console.log( a + b );
}
var b = 2;
foo(2);
```

对 b 进行的 RHS 引用无法在函数 foo 内部完成，但可以在上一级作用域中完成。

## 异常

为什么我们要去区分 LHS 和 RHS ？

因为在变量还没有声明之前（在任何作用域都无法找到该变量）的情况下，这两种查询的行为是不一样的。

```text
function foo(a) {
	console.log( a + b );
	b = a;
}
foo(2);
```

第一次对 b 进行 RHS 查询时是无法找到该变量的。也就是说，这是一个“未声明”的变量。如果 RHS 查询在所有嵌套的作用域中都无法找到它，那么引擎就会抛出一个 ReferenceError 异常。相较之下，当引擎执行 LHS 查询时，如果在全局作用域中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非“严格模式”下。

但是如果是在”严格模式“下，会禁止自动或隐式地创建全局变量。因此，在“严格模式”下 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询失败时类似的 ReferenceError 异常。

接下来，如果 RHS 查询到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如对一个非函数类型的值进行函数调用，那么引擎就会抛出另一种类型的异常，叫做 TypeError。

所以 ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。



# 词法作用域

作用域共有两种主要的工作模型。第一种是最为普通的，被大多数编程语言所采用的词法作用域，另外一种叫做动态作用域，还有一些编程语言在使用（比如 Bash 脚本，Perl 中的一些模式等）。

在这里，我们主要讲解词法作用域。

```text
function foo(a) {
	var b = a * 2;
	function bar(c) {
		console.log(a, b, c);
	}
	bar(b * 3)
}
foo(2);
```

这个例子中有三个逐级嵌套的作用域，为了帮助理解，我们可以把它想象成几个逐级包含的气泡。

1. 包含着整个全局作用域，其中只有一个标识符：foo。

2. 包含着 foo 所创建的作用域，其中有三个标识符： a， bar 和 b。

3. 包含着 bar 所创建的作用域，其中只有一个标识符：c。

   ​

这里所说的气泡是严格包含的，没有任何函数的气泡可以（部分的）同时出现在两个外部作用域的气泡中，就如同没有任何函数可以部分的同时出现在两个父级函数中一样。

### 查找

作用域气泡结构和相互之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符位置。

在上面的例子中，引擎执行```console.log(…)```声明，并查找a、b 和 c 三个变量的引用。它首先从最内部的作用域，也就是```bar(..)```函数的作用域气泡开始查找。引擎无法从这里找到，因此会去上一级到所嵌套的```foo(…)```的作用域中去继续查找。在这里找到了 a。因此引擎使用了这个引用。对于 c 来说，引擎在```bar(…)```中就找到了它。

这里要注意一点，作用域查找会在找到第一个匹配的标识符时停止。在多层嵌套作用域中可以定义同名的标识符，这叫做“遮蔽效应”，就是指内部的标识符遮蔽了外部的标识符。抛开遮蔽效应，作用域查找会始终从运行时最内部的作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。

**注意**：全局变量会自动成为全局对象的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问。

```window.a```

通过这种技术可以访问那些被同名变量所遮蔽的全局变量，但是非全局变量如果被遮蔽了，就无论如何都无法被访问到。



# 函数作用域和块作用域

## 函数中的作用域

考虑一下下面的代码

```text
function foo(a) {
	var b = 2;
	function bar() {
	...
	}
	var c = 3;
}
```

在这个代码片段中，foo的作用域气泡中包含了标识符a、b、c 和 bar。无论标识符声明出现在作用域的何处，这个标识符所代表的变量或函数都将附属于作用域的气泡。因此无法从foo(..)的外部去对它们进行访问。也就是说，这些标识符无法从全局作用域中进行访问，因此下面的代码会导致 ReferenceError 错误。

```text
bar();
console.log(a, b, c);
```

但是这些标识符在 foo 内部都是可以被访问的，同样在 bar 内部也是可以被访问的。

函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用。

### 隐藏内部实现

对函数的传统认识就是先声明一个函数，然后再想里面添加代码。但是如果我们反过来考虑，从写好的代码里选出一个片段，然后用函数声明对它进行包装，实际上就是把这些代码“隐藏”起来了。

为什么这个“隐藏函数或者变量”是一个有用的技术呢

 很多原因促成了这个基于作用域的隐藏方法。它们大多是从最小特权原则中引申出来的，也被称为最小暴露原则。这个原则是指在软件设计中，应该最小限度的暴露必要内容，从而将其他内容隐藏起来。

例如下面这段代码

```tex
function doSomething(a) {
	b = a + doSomethingElse(a * 2);
	console.log(b * 3);
}
function doSomethingElse(a) {
	return a - 1;
}
var b;
dosomething(2); // 15
```

在这段代码中，变量 b 和函数  doSomethingElse() 应该是 doSomething() 的内部私有内容，把它们暴漏在外面，给予外部作用域对它们的访问权限不仅没有必要，而且可能是危险的，因为它们可能会有意或无意的被以非预期的方式使用，从而导致超出了 doSomething 的适用条件。

更合理的设计应该是将这些私有的具体内容隐藏在 doSomething 内部

```te
function doSomething(a) {
	function doSomethingElse(a) {
		return a - 1;
	}
	var b;
	b = a + doSomethingElse(a * 2);
	console.log(b * 3);
}
doSomething(2); // 15
```

这样以来，b 和 doSomethingElse 都无法从外部被访问，只能被 doSomethingEles 所控制。

## 块作用域

尽管函数作用域是最常见的作用域单元，当然也是现在普遍的设计方法，但是其他类型的作用域单元也是存在的。

```tex
for(var i = 0; i < 10; i++) {
	console.log(i);
}
```

我们想在 for 循环的头部直接定义了变量 i ， 通常是因为只想在 for 循环内部的上下文中使用 i ，而忽略了 i 会被绑定在外部作用域中的事实。

所以在这里，ES6 引入了新的 let 关键字，提供除了 var 以为的另一种变量声明方式。

let 关键字可以将变量绑定到所在的任意作用域中，换句话说，let 为其声明隐式地创建了一个块作用域

```text
var foo = true;
if(foo) {
	{
	let bar = foo * 2;
	bar = something(bar);
	console.log(bar);
	}
}
console.log(bar); // ReferenceError
```

Let 可以发挥优势的典型例子就是 for 循环。

```text
for(let i = 0; i < 10; i++){
	console.log(i);
}
console.log(i); // ReferenceError
```

for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。

```text
{
	let j;
	for(j = 0; j < 10; j++) {
		let i = j;
		console.log(i);
	}
}
```

let 的另外一个特点就是不会在块作用域中进行提升，也就是在声明的代码被运行之前，声明并不存在。

```text
{
	console.log(bar); // ReferenceError
	let bar = 2;
}
```

除了 let 以外，ES6 还引入了const，同样可以用来创建块作用域变量，但是其值是固定的，之后任何试图修改值的操作都会引起错误。

```text
var foo = true;
if (foo) {
	{
        var a = 2;
        const b = 3;
        a = 3; // 正确
        b = 4; // 错误
	}
}
console.log(a); // 3
console.log(b); // ReferenceError
```

#  提升

首先考虑一下这个代码

```text
a = 2;
var a;
console.log(a); // undefined or 2
```

再考虑另外一段代码

```text
console.log(a);
var a = 2; // undefined or ReferenceError or 2
```

之所以会这样，就要想起之前说过的 JS 对于 var a = 2；的处理

所以，上面的代码实际上是这样执行的

```text
var a;
a = 2;
console.log(a);

var a;
console.log(a);
a = 2
```

因此，这个过程就好像变量和函数声明从它们在代码出现的位置被移动到了最上面，这个过程叫做提升。

也就是先有声明，后有赋值。

但是要注意，只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。

变量声明是如此，那么函数声明呢？

```text
foo();
function foo() {
	console.log(a); // undefined
	var a = 2;
}
```

这里的 foo函数声明被提升了，所以第一行中的调用可以正常运行

```text
function foo() {
	var a;
	console.log(a); // undefined
	a = 2;
}

foo();
```

但是有一件事情需要注意，函数声明可以被提升，但是函数表达式不会。

```text
foo(); // TypeError
bar(); // ReferenceError
var foo = function bar() {
	...
}
```

这段代码经过提升后，实际上会被理解为以下形式：

```text
var foo;

foo();
bar();

foo = function() {
	var bar = ...self..
	...
}
```

## 函数优先

从上面我们知道了函数声明和变量声明都会被提升，但是哪个会被先提升呢？

我们用一个例子来测试一下

```  {
foo(); // 1
var foo;
fucton foo(){
	console.log(1);
}
foo = function() {
	console.log(2);
}
```

这段代码会被引擎理解成如下形式

```text
function foo() {
	console.log(1);
}
foo(); //1
foo = function() {
	console.log(2);
}
```

 这里面 var foo 尽管出现在 function foo() 之前，但是他是重复声明，因此被忽略了，因为函数声明会被提升到普通变量之前。

尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的

```text
foo(); // 3
function foo() {
	console.log(1);
}
var foo = fuction() {
	console.log(2);
}
fuction foo() {
    console.log(3);
}
```

