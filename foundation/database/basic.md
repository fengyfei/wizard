与数据库相关的树结构主要为 B 类树，B 类树通常用于数据库和操作系统的文件系统

在学习 B 类树之前先复习一下二叉查找树的概念和红黑树

## 二叉查找树

[二叉树 - Binary Tree](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91) 是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。

### 分类

- 完美二叉树 (Perfect Binary Tree): 除了叶子结点之外的每一个结点都有两个孩子，每一层(当然包含最后一层)都被完全填充
- 完全二叉树 (Complete Binary Tree): 除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向左对齐
- 满二叉树 (Full/Strictly Binary Tree): 除了叶子结点之外的每一个结点都有两个孩子结点

### 遍历

- 前序遍历: 首先访问根结点然后遍历左子树，最后遍历右子树。在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树
- 中序遍历: 首先遍历左子树，然后访问根结点，最后遍历右子树。在遍历左、右子树时，仍然先遍历左子树，再访问根结点，最后遍历右子树
- 后序遍历: 首先遍历左子树，然后遍历右子树，最后访问根结点。在遍历左、右子树时，仍然先遍历左子树，然后遍历右子树，最后遍历根结点


- 深度优先搜索: 顾名思义，查找时深度优先，从根结点访问最远的结点直到找到所有节点。前序，中序和后序遍历都是深度优先遍历的特例
- 广度优先搜索: 广度优先遍历会先访问离根节点最近的节点，二叉树的广度优先遍历又称按层次遍历。算法借助队列实现

### 二叉查找树

[二叉查找树 - Binary Search Tree](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9): 也称二叉搜索树、有序二叉树。对于根树和所有子树都满足，每个节点都大于左子树元素，而小于右子树元素，**且没有键值相等的结点**

搜索、插入、删除的复杂度等于**树高**，期望 $$ O(\log_2^n) $$，最坏 O(n)（数列有序，树退化成线性表）

### 缺陷

当数据基本有序时，二叉查找树会退化成线性表，查找效率严重下降

所以后面出现了很多改进的[平衡树](https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%A1%E6%A0%91)结构以满足树高最坏也为 $$ O(\log_2^n) $$，
如[伸展树 (Splay Tree)](https://zh.wikipedia.org/wiki/%E4%BC%B8%E5%B1%95%E6%A0%91)、平衡二叉树 (SBT)、[AVL 树](https://zh.wikipedia.org/wiki/AVL%E6%A0%91)、红黑树等

## 红黑树

[红黑树 - Red–black tree](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91) 是一种自平衡二叉查找树，除了符合二叉查找树的性质外，它还满足以下五条性质:

1. 每个结点要么是红的，要么是黑的
2. 根结点是黑的
3. 每个叶子结点是黑的（叶子结点指树尾端 NIL 指针或 NULL 结点，不包含数据，只充当树在此结束的指示）
4. 如果一个结点是红的，那么它的两个子节点都是黑的 (从根到每个叶子的所有路径上不能有两个连续的红色节点)
5. 对于任一结点而言，其到叶结点树尾端 NIL 指针的每一条路径都包含相同数目的黑结点

![一棵红黑树](images/tree-0.svg)

### 平衡优势

上述约束确保了红黑树的关键特性: **从根到叶子的最长路径不会超过最短路径的两倍**

证明: 主要看性质 4 和 性质 5，假设从根到叶子的最短路径 a 上有黑色节点 n 个，最长路径 b 肯定是交替的红色和黑色节点，而根据性质 5 可知从根到叶子的所有路径都有相同数目的黑色节点，
这就表明 b 的黑色节点也为 n 个，但 b 出现的红色节点不可能超过黑色节点个数，否则会破坏性质 4 (抽屉原理)，所以从根到叶子的最长路径不会超过最短路径的两倍

### 调整

因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。然而，在红黑树上进行插入操作和删除操作会导致不再匹配红黑树的性质。
恢复红黑树的性质需要少量 $$ O(\log_2^n) $$ 的颜色变更（实际是非常快速的）和不超过三次树旋转（对于插入操作是两次）。虽然插入和删除很复杂，但操作时间仍可以保持为 $$ O(\log_2^n) $$ 次。

红黑树发生变更时需要 [变色] 和 [旋转] 来调整，其中旋转又分 [左旋] 和 [右旋]。

- 变色就是更改颜色
- 左旋: 以 X 为支点`逆时针`旋转红黑树的两个节点 X-Y，使得父节点被自己的右孩子取代，而自己下降为左孩子

![左旋](images/left.svg)

- 右旋: 以 X 为支点`顺时针`旋转红黑树的两个节点 X-Y，使得父节点被自己的左孩子取代，而自己下降为右孩子

![右旋](images/right.svg)

旋转过程中只需要做三次指针变更就行

### 插入和删除

#### 插入节点

插入节点的位置跟二叉查找树的寻找方法基本一致，如果插入结点 z 小于当前遍历到的结点，则到当前结点的左子树中继续查找，如果 z 大于当前结点，则到当前结点的右子树中继续查找，
如果 z 依然比此刻遍历到的新的当前结点小，则 z 作为当前结点的左孩子，否则作为当前结点的右孩子。而红黑树插入节点后，为了保持约束还需要进行调整修复(变色加旋转)。

所以插入步骤如下: 红黑树按二叉查找树的规则找到位置后插入新节点 z，z 的左孩子、右孩子都是叶子结点 nil， z 结点初始都为红色，再根据下述情形进行变色旋转等操作，最后达到平衡。

- 情形 1: 如果**当前节点是根结点**，为满足性质 2，所以直接把此结点 z 涂为黑色
- 情形 2: 如果**当前结点的父结点是黑色**，由于不违反性质 2 和性质 4，红黑树没有被破坏，所以此时也是什么也不做

比如上图插入 12 时满足情形 2:

![插入 12](images/tree-1.svg)

以下情形需要作出额外调整:

- 情形 3: 如果**当前结点的父结点是红色**且**祖父结点的另一个子结点(叔叔结点)是红色**
- 情形 4: **当前结点的父结点是红色**，**叔叔结点是黑色**或者 nil，当前结点相对其父结点的位置和父节点相对祖父节点的位置**不在同侧**
- 情形 5: **当前结点的父结点是红色**，**叔叔结点是黑色**或者 nil，当前结点相对其父结点的位置和父节点相对祖父节点的位置**在同侧**

下面着重讲讲后三种情况如何调整

##### 情形 3

`当前结点的父结点是红色且祖父结点的另一个子结点(叔叔结点)是红色`

> 因为当前节点的父节点是红色，所以父节点不可能是根节点，当前节点肯定有祖父节点，也就有叔叔节点

**解决步骤**: 将当前结点的父结点和叔叔结点涂黑，祖父结点涂红，再把祖父结点当做新节点(即当前节点的指针指向祖父节点)重新检查各种情形进行调整

由于对称性，不管父结点是祖父结点的左子还是右子，当前结点是其父结点的左子还是右子，处理都是一样的

我们插入 21 这个元素，当前节点指向 21：

![插入 21](images/tree-2.svg)

此时会发现 21、22 两个红色相连与性质 4 冲突，但 21 节点满足情形 3，修复后:

![调整情形 3](images/tree-3.svg)

此时当前节点指向 21 的祖父节点，即 25。而 25 节点同样遇到情形 3 的问题，继续修复:

![继续调整情形 3](images/tree-4.svg)

此时当前节点指向根节点，满足情形 1，将 14 节点涂黑即可恢复红黑树平衡

##### 情形 4

`当前结点的父结点是红色，叔叔结点是黑色或者 nil，当前结点相对其父结点的位置和父节点相对祖父节点的位置不在同侧`

**解决步骤**:

- 如果当前节点是父节点的右子，父节点是祖父节点的左子，以当前结点的父结点做为新结点(即当前节点的指针指向父节点)，并作为支点左旋
- 如果当前节点是父节点的左子，父节点是祖父节点的右子，以当前结点的父结点做为新结点(即当前节点的指针指向父节点)，并作为支点右旋

在上图的基础上我们继续插入 5 这个元素:

![插入 5](images/tree-5.svg)

可以看出 5 是父节点的左子，而父节点是祖父节点的右子，不同侧则为情形 4，将当前节点指向 5 的父节点 6，并以 6 为支点进行右旋:

![插入情形 4](images/tree-6.svg)

此时当前节点是 6，而 6 是父节点 5 的右子，父节点 5 也是祖父节点 1 的右子，同侧则转为情形 5，继续往下看

##### 情形 5

`当前结点的父结点是红色，叔叔结点是黑色或者 nil，当前结点相对其父结点的位置和父节点相对祖父节点的位置在同侧`

**解决步骤**:

- 首先把父结点变为黑色，祖父结点变为红色
- 如果当前节点是父节点的左子，父节点是祖父节点的左子，以祖父结点为支点右旋
- 如果当前节点是父节点的右子，父节点是祖父节点的右子，以祖父结点为支点左旋

在上一张图的基础上修改节点 5 为黑色，节点 1 为红色，再以 1 为支点左旋:

![插入情形 5](images/tree-7.svg)

此时便恢复平衡

#### 删除节点

删除节点 X 时第一步先判断两个孩子是否都是非空的，如果都非空，就先按二叉查找树的规则处理:

在删除带有两个非空子树的节点 X 的时候，我们可以找到左子树中的最大元素(或者右子树中的最小元素)，并把这个最值**复制**给 X 节点，只代替原来要删除的值，不改变节点颜色。

然后我们只要删除那个被复制出值的那个节点就行，因为是最值节点所以它的孩子不可能都非空。

因为只是复制了一个值，不违反任何性质，这就把原问题转化为**如何删除最多有一个非空子树的节点的问题**。它不关心这个节点是最初要删除的节点还是被复制出值的那个节点。

我们以图为例，图中三角形代表可能为空的子树:

![取值复制](images/removal-0.svg)

节点 X 是要删除的节点，发现它的两个子树非空，我们可以找左子树中最大的元素 Max (也可以找右子树中最小的元素 Min)，把 Max 值(或者 Min 值)复制到 X 上覆盖原来的值，不修改其他属性，然后删除 Max 节点(或 Min 节点)即可，可以很清楚的看到最值节点最多只会有一个非空子树

---

接下来就是如何处理删除最多有一个非空子树的节点 X 的问题

简单情形:

1. 如果 X 的两个儿子都为空，即均为叶子，我们将其中任意一个看作它的儿子
2. 如果 **X 是一个红色节点**，它的父亲和儿子一定是黑色的，所以简单的**用它的黑色儿子替换它**就行，这并不会破坏性质 3 和性质 4，通过被删除节点的所有路径只是少了一个红色节点，这样可以继续保证性质 5
3. 如果 **X 是黑色而它的儿子是红色**，如果只是删除这个黑色节点，**用它的红色儿子代替**的话，会破坏性质 5，我们可以**重绘它的儿子为黑色**，则曾经通过 X 的所有路径将通过它的黑色儿子，这样可以继续保持性质 5

如果 X 和它的儿子都是黑色，这是一种复杂的情况，我们单拎出来讲

我们首先把要删除的节点 X 替换为它的儿子。出于方便，称呼这个新上位的儿子为 N，称呼它的兄弟为 S，使用 P 称呼 N 的新父亲，SL 称呼 S 的左儿子，SR 称呼 S 的右儿子

有以下六种情形需要考虑:

##### 情形 1

N 是新的根

我们不需要做什么，因为所有路径都去除了一个黑色节点，而新根也是黑色的，所以性质都保持着

> 情形 2、5、6 涉及到左右不同的情况，只取一种处理

##### 情形 2

S 是红色

- 交换兄弟 S 和父亲 P 的颜色
- 如果 N 是其父亲的左节点，我们在 N 的父亲上做左旋，把红色兄弟转换成 N 的祖父
- 如果 N 是其父亲的右节点，我们在 N 的父亲上做右旋，把红色兄弟转换成 N 的祖父

![删除情形 2](images/removal-2.svg)

完成这两个操作后，尽管所有路径上黑色节点的数目没有改变，但现在 N 有了一个黑色的兄弟和一个红色的父亲，所以我们可以接下去按情形 4、情形 5 或情形 6 来处理

##### 情形 3

N 的父亲、S 和 S 的儿子都是黑色的

- 重绘 S 为红色
- 将 P 作为新的 N，从情形 1 开始，在 P 上做平衡处理

![删除情形 3](images/removal-3.svg)

在这种情形下，我们简单的重绘 S 为红色。结果是通过 S 的所有路径都少了一个黑色节点。这与删除 N 的初始父亲 X 造成通过 N 的所有路径少了一个黑色节点达成平衡。但是，通过 P 的所有路径现在比不通过 P 的路径少了一个黑色节点，所以仍然违反性质 5。要修正这个问题，我们要从情形 1 开始，在 P 上做重新平衡处理

##### 情形 4

S 和 S 的儿子都是黑色，但是 N 的父亲是红色

- 交换 N 的兄弟 S 和父亲 P 的颜色

![删除情形 4](images/removal-4.svg)

在这种情形下，我们简单的交换 N 的兄弟和父亲的颜色。这不影响不通过 N 的路径的黑色节点的数目，但是它在通过 N 的路径上对黑色节点数目增加了一，添补了在这些路径上删除的黑色节点

##### 情形 5

S 是黑色，S 的其中一个儿子是红色，且红色儿子的位置与 N 相对于父亲的位置处于**同侧**

- 如果 N 是其父亲的左节点，S 的左儿子是红色，右儿子是黑色，则在 S 上做右旋转
- 如果 N 是其父亲的右节点，S 的左儿子是黑色，右儿子是红色，则在 S 上做左旋转
- 将 S 和它之前的红色儿子交换颜色

![删除情形 5](images/removal-5.svg)

所有路径仍有同样数目的黑色节点，但是现在 N 有了一个黑色兄弟，且兄弟的一个儿子仍为红色的，其位置与 N 相对于父亲的位置处于不同侧，进入情形 6

> 情形 5、6 中父节点 P 的颜色可以为黑色也可以是红色

##### 情形 6

S 是黑色，S 的其中一个儿子是红色，且其位置与 N 相对于父亲的位置处于**不同侧**

- 交换 N 的父亲 P 和 S 的颜色
- 如果 N 是其父亲的右节点，S 的左儿子是红色，右儿子是黑色，则在 N 的父亲上做右旋转，并使 S 的左儿子涂黑
- 如果 N 是其父亲的左节点，S 的左儿子是黑色，右儿子是红色，则在 N 的父亲上做左旋转，并使 S 的右儿子涂黑

![删除情形 6](images/removal-6.svg)

交换前 N 的父亲可以是红色也可以是黑色，交换后，N 增加了一个黑色祖先，所以通过 N 的路径都增加了一个黑色节点，S 的右子树黑色节点个数也没有变化，达到平衡

##### 实例

还是以之前的图为例

![删除](images/tree-7.svg)

我们自下而上开始尝试删除每一个节点:

- 假如要删除元素 1，根据简单情形中的第二条，我们直接删除 1，并用一个 nil 节点代替即可，元素 6、12、21 的处理与此相同

- 假如要删除元素 5，因为左右子树均不为空，所以找左子树的最大值 1 (或者右子树的最小值 6)，用找到的值代替 5 (这里只是值替换，其他均不变)，然后去删除 1 节点，这就转到问题 1 上了

- 假如要删除元素 11，根据简单情形的第三条，我们直接删除 11，并用子节点 12 代替，同时把 12 涂黑即可，元素 22 的处理与此相同

- 假如要删除元素 25，因为左右子树均不为空，所以找左子树的最大值 22 (或者右子树的最小值 27)，我们这里用值 22 代替 25，颜色不变。然后去删除 22 节点，这变成上一个问题了

- 假如要删除元素 27，黑色的 nil 叶子节点代替 27 节点，因为兄弟节点 22 有一个红色孩子，且在左边，和 nil 节点相对父亲 25 的位置不同侧，属于情形 6，所以第一步交换 22 和 25 的颜色，再以 25 为支点做右旋转，然后将 21 节点涂黑即可

- 假如要删除元素 8，选择右子树最小值 11 替换 8。然后去删除节点 11，对应问题 3

- 假如要删除元素 17，选择左子树最大值 15 替换 17。然后去删除节点 15，过程看下一个问题

- 假如要删除元素 15，删除的元素和替代的元素都是黑色，这属于复杂情形。检查其类型可以匹配到情形 2，元素 15 是被移除的 X，代替它的是 nil 节点，即为 N，17 为 P，25 为 S，根据上文可知第一步先交换 P 和 S 的颜色，然后以 P 为支点进行左旋，此时 N 多了一个黑色的兄弟 22 和红色的父亲 17:

![删除 15](images/example-0.svg)

此时 N 的兄弟 S 变为 22，P 变为 17，S 的左孩子是红色的 21，属于情形 5。S 做右旋转，并交换 22 和 21 的颜色:

![删除 15](images/example-1.svg)

此时 N 的兄弟 S 变为黑色的 21，但 21 的红色孩子节点 22 变为右侧，进入情形 6

![删除 15](images/example-2.svg)

P 节点 17 做左旋转，并将 S 的右节点涂黑，此时树恢复平衡

- 假如要删除跟节点 14，取左子树最大值 12 代替 14。然后去删除节点 12，对应问题 1

至此，我们已经把节点都删了个遍，相信你对红黑树的删除操作应该了解了

## 实际问题

红黑树还是典型的二叉搜索树结构，主要应用在一些 map 和 set 类型的实现上，比如 Java 中的 TreeMap 和 C++ 的 set/map/multimap 等。其查找的时间复杂度 $$ O(\log_2^n) $$ 与树的深度相关，降低树的深度可以提高查找效率。

但是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），这样导致二叉查找树结构由于树的深度过大而造成磁盘 I/O 读写过于频繁，进而导致查询效率低下，因此我们该想办法降低树的深度，从而减少磁盘查找存取的次数。一个基本的想法就是：采用`多叉树结构`

所以出现了下述的平衡多路查找树

## B 树 (B - Tree)

> B-树，即为 B 树，不要读作 B 减树

B 树与红黑树最大的不同在于，B 树的结点可以有许多子女，从几个到几千个。

### 定义

[B 树](https://zh.wikipedia.org/wiki/B%E6%A0%91)又叫平衡多路查找树。一棵 m 阶(m 阶即代表树中任一结点最多含有m个孩子)的 B 树的特性如下:

1. 每个中间节点都包含 i-1 个元素和 i 个孩子，其中 $$ \frac m2 $$ <= i <= m
2. 根结点至少有 2 个孩子（除非 B 树只存在一个节点: 根结点）
3. 每一个叶子节点都包含 j-1 个元素，其中 $$ \frac m2 $$ <= j <= m
4. 所有叶子结点都出现在同一层
5. 每个节点中的元素从小到大排列，节点当中 k-1 个元素正好是 k 个孩子包含的元素的值域分划

![2-3-4 树](images/B-Tree-0.svg)

如图是一个典型的 [2-3-4 树](https://zh.wikipedia.org/wiki/2-3-4%E6%A0%91)结构，也是阶为 4 的 B 树。从图中查询元素最多只需要 3 次磁盘 I/O 就可以访问到我们需要的数据节点，将节点数据块读入内存后再查找指定元素会很快。如果同样的数据用红黑树表示，树高会增长很多，造成遍历节点的次数增多，访问磁盘的次数增多，查找性能会下降。

对于一棵包含 n 个元素、高度为 h 、阶数为 m 的 B 树:
影响 B 树高度的是每个结点所包含的子树数，如果尽可能使结点孩子数都等于 $$ \lceil\frac m2\rceil $$，则层数最多，为最坏情况；如果尽可能使结点孩子数都等于 m，则层数最少，为最好情况。所以有

$$ \log_m{(n + 1)} \leq h \leq \log_{\lceil\frac m2\rceil}{(\frac{n + 1}{2})} + 1$$

底数 $$ \frac m2 $$ 可以取很大，如 m 可以达到几千，从而在关键字数一定的情况下，使得最终的 h 值尽量比较小，树的高度比较低。

实际运用中 B 树中的每个结点根据实际情况可以包含大量的关键字信息和分支(但不能超过磁盘块的大小，根据磁盘驱动的不同，一般块的大小在 1k~4k 左右)；这样树的深度降低了，意味着查找一个元素只要很少的结点从外存磁盘中读入内存，就可以很快地访问到要查找的数据

## B+ 树 (B+ - Tree)

[B+ 树](https://zh.wikipedia.org/wiki/B%2B%E6%A0%91) 是基于 B 树的变体

## B\* 树 (B\* - Tree)

B* 树是 B+ 树的变体，在 B+ 树的基础上(所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针)，B* 树中非根和非叶子结点再增加指向兄弟的指针；B* 树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）

## Reference

- [wikipedia - 红黑树](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)
- [什么是B-树](https://mp.weixin.qq.com/s/rDCEFzoKHIjyHfI_bsz5Rw)
- 《编程之法: 面试和算法心得》
